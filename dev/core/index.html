<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Core &amp; Interfaces · Lattice2DMonteCarlo.jl</title><meta name="title" content="Core &amp; Interfaces · Lattice2DMonteCarlo.jl"/><meta property="og:title" content="Core &amp; Interfaces · Lattice2DMonteCarlo.jl"/><meta property="twitter:title" content="Core &amp; Interfaces · Lattice2DMonteCarlo.jl"/><meta name="description" content="Documentation for Lattice2DMonteCarlo.jl."/><meta property="og:description" content="Documentation for Lattice2DMonteCarlo.jl."/><meta property="twitter:description" content="Documentation for Lattice2DMonteCarlo.jl."/><meta property="og:url" content="https://sotashimozono.github.io/Lattice2DMonteCarlo.jl/core/"/><meta property="twitter:url" content="https://sotashimozono.github.io/Lattice2DMonteCarlo.jl/core/"/><link rel="canonical" href="https://sotashimozono.github.io/Lattice2DMonteCarlo.jl/core/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Lattice2DMonteCarlo.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">API Reference</span><ul><li class="is-active"><a class="tocitem" href>Core &amp; Interfaces</a></li><li><a class="tocitem" href="../models/">Models</a></li><li><a class="tocitem" href="../algorithms/">Algorithms</a></li><li><a class="tocitem" href="../visualization/">Visualization</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API Reference</a></li><li class="is-active"><a href>Core &amp; Interfaces</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Core &amp; Interfaces</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/sotashimozono/Lattice2DMonteCarlo.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/sotashimozono/Lattice2DMonteCarlo.jl/blob/main/docs/src/core.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Core-and-Interfaces"><a class="docs-heading-anchor" href="#Core-and-Interfaces">Core &amp; Interfaces</a><a id="Core-and-Interfaces-1"></a><a class="docs-heading-anchor-permalink" href="#Core-and-Interfaces" title="Permalink"></a></h1><p>Base structures and abstract types for the simulation.</p><article><details class="docstring" open="true"><summary id="Lattice2DMonteCarlo.AbstractModel"><a class="docstring-binding" href="#Lattice2DMonteCarlo.AbstractModel"><code>Lattice2DMonteCarlo.AbstractModel</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>AbstractModel{T}: Abstract type for lattice models in Monte Carlo simulations. T: The state type of the model (e.g., Int, Float64, Vector, etc.). if you want to define a new model, subtype this abstract type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sotashimozono/Lattice2DMonteCarlo.jl/blob/42bb75a32aaf160dda86552f7be10326b3d87e04/src/core/abstracttypes.jl#L9-L13">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Lattice2DMonteCarlo.AbstractMonteCarlo"><a class="docstring-binding" href="#Lattice2DMonteCarlo.AbstractMonteCarlo"><code>Lattice2DMonteCarlo.AbstractMonteCarlo</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>AbstractMonteCarlo: Abstract type for Monte Carlo simulation components.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sotashimozono/Lattice2DMonteCarlo.jl/blob/42bb75a32aaf160dda86552f7be10326b3d87e04/src/core/abstracttypes.jl#L4-L6">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Lattice2DMonteCarlo.AbstractObserver"><a class="docstring-binding" href="#Lattice2DMonteCarlo.AbstractObserver"><code>Lattice2DMonteCarlo.AbstractObserver</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>AbstractObserver: Abstract type for observers in Monte Carlo simulations. it is used to monitor physical quantities during the simulation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sotashimozono/Lattice2DMonteCarlo.jl/blob/42bb75a32aaf160dda86552f7be10326b3d87e04/src/core/abstracttypes.jl#L16-L19">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Lattice2DMonteCarlo.AcceptanceRule"><a class="docstring-binding" href="#Lattice2DMonteCarlo.AcceptanceRule"><code>Lattice2DMonteCarlo.AcceptanceRule</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>AcceptanceRule: Abstract type for acceptance rules in Monte Carlo simulations. SiteSelectionMethod: Abstract type for site selection methods in Monte Carlo simulations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sotashimozono/Lattice2DMonteCarlo.jl/blob/42bb75a32aaf160dda86552f7be10326b3d87e04/src/core/abstracttypes.jl#L37-L40">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Lattice2DMonteCarlo.ClusterUpdateAlgorithm"><a class="docstring-binding" href="#Lattice2DMonteCarlo.ClusterUpdateAlgorithm"><code>Lattice2DMonteCarlo.ClusterUpdateAlgorithm</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>ClusterUpdateAlgorithm: Abstract type for cluster update algorithms. it is used for wolff algorithm, swendsen-wang algorithm, etc.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sotashimozono/Lattice2DMonteCarlo.jl/blob/42bb75a32aaf160dda86552f7be10326b3d87e04/src/core/abstracttypes.jl#L31-L34">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Lattice2DMonteCarlo.Glauber"><a class="docstring-binding" href="#Lattice2DMonteCarlo.Glauber"><code>Lattice2DMonteCarlo.Glauber</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Glauber: Acceptance rule based on the Glauber dynamics. <code>1 / (1 + e^(dE/kbT))</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sotashimozono/Lattice2DMonteCarlo.jl/blob/42bb75a32aaf160dda86552f7be10326b3d87e04/src/core/abstracttypes.jl#L94-L97">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Lattice2DMonteCarlo.LocalChange"><a class="docstring-binding" href="#Lattice2DMonteCarlo.LocalChange"><code>Lattice2DMonteCarlo.LocalChange</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>LocalChange{T}: Represents a local change at a single site. T: The state type of the model (e.g., Int, Float64, Vector, etc.).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sotashimozono/Lattice2DMonteCarlo.jl/blob/42bb75a32aaf160dda86552f7be10326b3d87e04/src/core/abstracttypes.jl#L55-L58">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Lattice2DMonteCarlo.LocalUpdate"><a class="docstring-binding" href="#Lattice2DMonteCarlo.LocalUpdate"><code>Lattice2DMonteCarlo.LocalUpdate</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>LocalUpdate{R&lt;:AcceptanceRule,S&lt;:SiteSelectionMethod,P&lt;:ProposalMethod}: Local update algorithm combining acceptance rule R, site selection method S, and proposal method P. this is a general structure for local update algorithms in Monte Carlo simulations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sotashimozono/Lattice2DMonteCarlo.jl/blob/42bb75a32aaf160dda86552f7be10326b3d87e04/src/core/abstracttypes.jl#L115-L118">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Lattice2DMonteCarlo.LocalUpdateAlgorithm"><a class="docstring-binding" href="#Lattice2DMonteCarlo.LocalUpdateAlgorithm"><code>Lattice2DMonteCarlo.LocalUpdateAlgorithm</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>LocalUpdateAlgorithm: Abstract type for local update algorithms. it is used for kawaski dynamics, metropolis updates, etc.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sotashimozono/Lattice2DMonteCarlo.jl/blob/42bb75a32aaf160dda86552f7be10326b3d87e04/src/core/abstracttypes.jl#L26-L29">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Lattice2DMonteCarlo.Metropolis"><a class="docstring-binding" href="#Lattice2DMonteCarlo.Metropolis"><code>Lattice2DMonteCarlo.Metropolis</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Metropolis: Acceptance rule based on the Metropolis criterion. <code>e^(-dE/kbT)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sotashimozono/Lattice2DMonteCarlo.jl/blob/42bb75a32aaf160dda86552f7be10326b3d87e04/src/core/abstracttypes.jl#L88-L91">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Lattice2DMonteCarlo.ProposalMethod"><a class="docstring-binding" href="#Lattice2DMonteCarlo.ProposalMethod"><code>Lattice2DMonteCarlo.ProposalMethod</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>ProposalMethod: Abstract type for proposal methods in Monte Carlo simulations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sotashimozono/Lattice2DMonteCarlo.jl/blob/42bb75a32aaf160dda86552f7be10326b3d87e04/src/core/abstracttypes.jl#L46-L48">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Lattice2DMonteCarlo.RandomSiteSelection"><a class="docstring-binding" href="#Lattice2DMonteCarlo.RandomSiteSelection"><code>Lattice2DMonteCarlo.RandomSiteSelection</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>RandomSiteSelection: Site selection method that selects sites randomly. when you consider non equilibrium dynamics, this method is recommended.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sotashimozono/Lattice2DMonteCarlo.jl/blob/42bb75a32aaf160dda86552f7be10326b3d87e04/src/core/abstracttypes.jl#L102-L105">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Lattice2DMonteCarlo.SequentialSweep"><a class="docstring-binding" href="#Lattice2DMonteCarlo.SequentialSweep"><code>Lattice2DMonteCarlo.SequentialSweep</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>SequentialSweep: Site selection method that sweeps through sites sequentially.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sotashimozono/Lattice2DMonteCarlo.jl/blob/42bb75a32aaf160dda86552f7be10326b3d87e04/src/core/abstracttypes.jl#L108-L110">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Lattice2DMonteCarlo.SiteSelectionMethod"><a class="docstring-binding" href="#Lattice2DMonteCarlo.SiteSelectionMethod"><code>Lattice2DMonteCarlo.SiteSelectionMethod</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>SiteSelectionMethod: Abstract type for site selection methods in Monte Carlo simulations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sotashimozono/Lattice2DMonteCarlo.jl/blob/42bb75a32aaf160dda86552f7be10326b3d87e04/src/core/abstracttypes.jl#L42-L44">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Lattice2DMonteCarlo.SpinExchange"><a class="docstring-binding" href="#Lattice2DMonteCarlo.SpinExchange"><code>Lattice2DMonteCarlo.SpinExchange</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>SpinExchange: Proposal method for exchanging spins between two sites (e.g., in Kawasaki dynamics). conserved dynamics.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sotashimozono/Lattice2DMonteCarlo.jl/blob/42bb75a32aaf160dda86552f7be10326b3d87e04/src/core/abstracttypes.jl#L71-L74">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Lattice2DMonteCarlo.SpinFlip"><a class="docstring-binding" href="#Lattice2DMonteCarlo.SpinFlip"><code>Lattice2DMonteCarlo.SpinFlip</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Spinfilp: Proposal method for flipping spins (e.g., in Ising model). non conserved dynamics.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sotashimozono/Lattice2DMonteCarlo.jl/blob/42bb75a32aaf160dda86552f7be10326b3d87e04/src/core/abstracttypes.jl#L65-L68">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Lattice2DMonteCarlo.UniformShift"><a class="docstring-binding" href="#Lattice2DMonteCarlo.UniformShift"><code>Lattice2DMonteCarlo.UniformShift</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>UniformShift(width::Float64 = 0.1) A proposal method for continuous spin models (e.g., XY, Heisenberg). Shifts the current value by a random amount drawn uniformly from <code>[-width/2, width/2]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sotashimozono/Lattice2DMonteCarlo.jl/blob/42bb75a32aaf160dda86552f7be10326b3d87e04/src/core/abstracttypes.jl#L77-L81">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Lattice2DMonteCarlo.UpdateAlgorithm"><a class="docstring-binding" href="#Lattice2DMonteCarlo.UpdateAlgorithm"><code>Lattice2DMonteCarlo.UpdateAlgorithm</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>UpdateAlgorithm: Abstract type for update algorithms in Monte Carlo simulations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sotashimozono/Lattice2DMonteCarlo.jl/blob/42bb75a32aaf160dda86552f7be10326b3d87e04/src/core/abstracttypes.jl#L22-L24">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Lattice2DMonteCarlo.calculate_diff_energy-Union{Tuple{T}, Tuple{AbstractVector{T}, Lattice2D.Lattice, AbstractModel{T}, Tuple{LocalChange{T}, LocalChange{T}, Vararg{LocalChange{T}}}}} where T"><a class="docstring-binding" href="#Lattice2DMonteCarlo.calculate_diff_energy-Union{Tuple{T}, Tuple{AbstractVector{T}, Lattice2D.Lattice, AbstractModel{T}, Tuple{LocalChange{T}, LocalChange{T}, Vararg{LocalChange{T}}}}} where T"><code>Lattice2DMonteCarlo.calculate_diff_energy</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">calculate_diff_energy(grids, lat, model, changes) -&gt; Float64</code></pre><p>Efficiently calculates the energy difference \Delta E associated with the proposed <code>changes</code>. Instead of recalculating the total energy, it considers only the changed sites and their neighbors.</p><p><strong>Arguments</strong></p><ul><li><code>changes</code>: A tuple of <a href="#Lattice2DMonteCarlo.LocalChange"><code>LocalChange</code></a>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sotashimozono/Lattice2DMonteCarlo.jl/blob/42bb75a32aaf160dda86552f7be10326b3d87e04/src/core/interfaces.jl#L142-L150">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Lattice2DMonteCarlo.check_acceptance-Tuple{Random.AbstractRNG, AcceptanceRule, Float64}"><a class="docstring-binding" href="#Lattice2DMonteCarlo.check_acceptance-Tuple{Random.AbstractRNG, AcceptanceRule, Float64}"><code>Lattice2DMonteCarlo.check_acceptance</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">check_acceptance(rng, rule, dE; kbT) -&gt; Bool</code></pre><p>Determines whether to accept the state transition based on the energy difference <code>dE</code> and temperature <code>kbT</code>.</p><p><strong>Arguments</strong></p><ul><li><code>rule::AcceptanceRule</code>: The acceptance rule (e.g., <a href="#Lattice2DMonteCarlo.Metropolis"><code>Metropolis</code></a>, <a href="#Lattice2DMonteCarlo.Glauber"><code>Glauber</code></a>).</li><li><code>dE::Float64</code>: The energy difference (E<em>{new} - E</em>{old}).</li></ul><p><strong>Returns</strong></p><ul><li><code>Bool</code>: <code>true</code> if the transition is accepted.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sotashimozono/Lattice2DMonteCarlo.jl/blob/42bb75a32aaf160dda86552f7be10326b3d87e04/src/core/interfaces.jl#L200-L211">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Lattice2DMonteCarlo.local_hamiltonian-Union{Tuple{T}, Tuple{AbstractVector{T}, Lattice2D.Lattice, AbstractModel{T}, Int64}} where T"><a class="docstring-binding" href="#Lattice2DMonteCarlo.local_hamiltonian-Union{Tuple{T}, Tuple{AbstractVector{T}, Lattice2D.Lattice, AbstractModel{T}, Int64}} where T"><code>Lattice2DMonteCarlo.local_hamiltonian</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">local_hamiltonian(grids, lat, model, site; val=grids[site]) -&gt; Float64</code></pre><p>Calculates the local interaction energy around the specified <code>site</code>. A virtual value <code>val</code> can be specified instead of the current state <code>grids[site]</code> for calculating energy differences.</p><p><strong>Arguments</strong></p><ul><li><code>site::Int</code>: The site index for calculation.</li><li><code>val::T</code>: The state value of the site. Defaults to the current <code>grids[site]</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>Float64</code>: The local energy value.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sotashimozono/Lattice2DMonteCarlo.jl/blob/42bb75a32aaf160dda86552f7be10326b3d87e04/src/core/interfaces.jl#L98-L110">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Lattice2DMonteCarlo.observe!-Union{Tuple{T}, Tuple{AbstractObserver, AbstractVector{T}, Lattice2D.Lattice, AbstractModel{T}, Int64}} where T"><a class="docstring-binding" href="#Lattice2DMonteCarlo.observe!-Union{Tuple{T}, Tuple{AbstractObserver, AbstractVector{T}, Lattice2D.Lattice, AbstractModel{T}, Int64}} where T"><code>Lattice2DMonteCarlo.observe!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">observe!(obs, grids, lat, kbT, model, step)</code></pre><p>Measures and records physical quantities from the current state. This function is called periodically within the <a href="#Lattice2DMonteCarlo.run!-Union{Tuple{T}, Tuple{Random.AbstractRNG, AbstractVector{T}, Lattice2D.Lattice, AbstractModel{T}, UpdateAlgorithm, AbstractVector{&lt;:AbstractObserver}}} where T"><code>run!</code></a> loop.</p><p><strong>Arguments</strong></p><ul><li><code>obs::AbstractObserver</code>: The specific observer instance (e.g., <a href="#Lattice2DMonteCarlo.FunctionObserver"><code>FunctionObserver</code></a>).</li><li><code>step::Int</code>: The current Monte Carlo step number.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sotashimozono/Lattice2DMonteCarlo.jl/blob/42bb75a32aaf160dda86552f7be10326b3d87e04/src/core/interfaces.jl#L216-L225">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Lattice2DMonteCarlo.process_site_selection!-Union{Tuple{T}, Tuple{Random.AbstractRNG, SiteSelectionMethod, AbstractVector{T}, Lattice2D.Lattice, AbstractModel{T}, UpdateAlgorithm}} where T"><a class="docstring-binding" href="#Lattice2DMonteCarlo.process_site_selection!-Union{Tuple{T}, Tuple{Random.AbstractRNG, SiteSelectionMethod, AbstractVector{T}, Lattice2D.Lattice, AbstractModel{T}, UpdateAlgorithm}} where T"><code>Lattice2DMonteCarlo.process_site_selection!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">process_site_selection!(rng, S, grids, lat, model, alg; kbT=1.0)</code></pre><p>Called as part of the <a href="#Lattice2DMonteCarlo.LocalUpdate"><code>LocalUpdate</code></a> algorithm. Selects a site based on the <a href="#Lattice2DMonteCarlo.SiteSelectionMethod"><code>SiteSelectionMethod</code></a> <code>S</code>, then executes <code>propose</code> and <code>check_acceptance</code>.</p><p><strong>Arguments</strong></p><ul><li><code>S::SiteSelectionMethod</code>: The site selection strategy (e.g., <a href="#Lattice2DMonteCarlo.RandomSiteSelection"><code>RandomSiteSelection</code></a>).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sotashimozono/Lattice2DMonteCarlo.jl/blob/42bb75a32aaf160dda86552f7be10326b3d87e04/src/core/interfaces.jl#L179-L187">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Lattice2DMonteCarlo.propose-Union{Tuple{T}, Tuple{Random.AbstractRNG, ProposalMethod, AbstractVector{T}, Lattice2D.Lattice, AbstractModel{T}, Int64}} where T"><a class="docstring-binding" href="#Lattice2DMonteCarlo.propose-Union{Tuple{T}, Tuple{Random.AbstractRNG, ProposalMethod, AbstractVector{T}, Lattice2D.Lattice, AbstractModel{T}, Int64}} where T"><code>Lattice2DMonteCarlo.propose</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">propose(rng, alg, grids, lat, model, site) -&gt; Tuple{LocalChange, ...}</code></pre><p>Proposes a new candidate state for a local update algorithm. This function does not actually modify <code>grids</code>, but returns a tuple of <a href="#Lattice2DMonteCarlo.LocalChange"><code>LocalChange</code></a> representing the proposed modifications.</p><p><strong>Arguments</strong></p><ul><li><code>alg::ProposalMethod</code>: The proposal method (e.g., <a href="#Lattice2DMonteCarlo.SpinFlip"><code>SpinFlip</code></a>, <a href="#Lattice2DMonteCarlo.SpinExchange"><code>SpinExchange</code></a>).</li><li><code>site::Int</code>: The index of the site to be updated.</li></ul><p><strong>Returns</strong></p><ul><li><code>Tuple{Vararg{LocalChange{T}}}</code>: A tuple containing change information for one or more sites.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sotashimozono/Lattice2DMonteCarlo.jl/blob/42bb75a32aaf160dda86552f7be10326b3d87e04/src/core/interfaces.jl#L74-L86">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Lattice2DMonteCarlo.run!-Union{Tuple{T}, Tuple{Random.AbstractRNG, AbstractVector{T}, Lattice2D.Lattice, AbstractModel{T}, UpdateAlgorithm, AbstractVector{&lt;:AbstractObserver}}} where T"><a class="docstring-binding" href="#Lattice2DMonteCarlo.run!-Union{Tuple{T}, Tuple{Random.AbstractRNG, AbstractVector{T}, Lattice2D.Lattice, AbstractModel{T}, UpdateAlgorithm, AbstractVector{&lt;:AbstractObserver}}} where T"><code>Lattice2DMonteCarlo.run!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">run!(rng, grids, lat, model, alg, observers; kbT=1.0, nsteps=1000, kwargs...)</code></pre><p>Run a Monte Carlo simulation with the specified parameters, updating the spin configuration <code>grids</code> in place.</p><p><strong>Arguments</strong></p><ul><li><code>rng::AbstractRNG</code>: random number generator for stochastic processes.</li><li><code>grids::AbstractVector{T}</code>: it represents the spin configuration of the lattice, where <code>T</code> is the type of spin (e.g., <code>Int</code> for Ising spins).</li><li><code>lat::Lattice</code>: lattice structure (topology, size, adjacency information).</li><li><code>model::AbstractModel{T}</code>: definition of the physical model (Ising, Potts, XY, etc.).</li><li><code>alg::UpdateAlgorithm</code>: update algorithm (e.g., <code>LocalUpdate</code>).</li><li><code>observers::AbstractVector</code>: list of <code>AbstractObserver</code>s for measurements.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>kbT::Float64</code>:  k_BT value for the simulation. Default is <code>1.0</code>.</li><li><code>nsteps::Int</code>: total number of simulation steps (MCS). Default is <code>1000</code>.</li><li><code>kwargs...</code>: other algorithm-specific parameters.</li></ul><p><strong>Execution Flow</strong></p><ol><li><strong>Initial Observation</strong>: Record the state at step 0 using <code>observe!</code>.</li><li><strong>Simulation Loop</strong>: Loop for <code>nsteps</code> iterations.<ul><li><code>update_step!</code>: Perform one Monte Carlo step update.</li><li><strong>Interval Observation</strong>: Call <code>observe!</code> when <code>step % obs.interval == 0</code>.</li></ul></li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sotashimozono/Lattice2DMonteCarlo.jl/blob/42bb75a32aaf160dda86552f7be10326b3d87e04/src/core/interfaces.jl#L7-L28">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Lattice2DMonteCarlo.run-Union{Tuple{T}, Tuple{Random.AbstractRNG, AbstractVector{T}, Lattice2D.Lattice, AbstractModel{T}, UpdateAlgorithm, AbstractVector{&lt;:AbstractObserver}}} where T"><a class="docstring-binding" href="#Lattice2DMonteCarlo.run-Union{Tuple{T}, Tuple{Random.AbstractRNG, AbstractVector{T}, Lattice2D.Lattice, AbstractModel{T}, UpdateAlgorithm, AbstractVector{&lt;:AbstractObserver}}} where T"><code>Lattice2DMonteCarlo.run</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">run(rng, grids, lat, model, alg, observers; kwargs...) -&gt; Vector{T}</code></pre><p><a href="#Lattice2DMonteCarlo.run!-Union{Tuple{T}, Tuple{Random.AbstractRNG, AbstractVector{T}, Lattice2D.Lattice, AbstractModel{T}, UpdateAlgorithm, AbstractVector{&lt;:AbstractObserver}}} where T"><code>run!</code></a> that returns a new spin configuration without modifying the original <code>grids</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sotashimozono/Lattice2DMonteCarlo.jl/blob/42bb75a32aaf160dda86552f7be10326b3d87e04/src/core/interfaces.jl#L55-L59">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Lattice2DMonteCarlo.total_energy-Union{Tuple{T}, Tuple{AbstractVector{T}, Lattice2D.Lattice, AbstractModel{T}}} where T"><a class="docstring-binding" href="#Lattice2DMonteCarlo.total_energy-Union{Tuple{T}, Tuple{AbstractVector{T}, Lattice2D.Lattice, AbstractModel{T}}} where T"><code>Lattice2DMonteCarlo.total_energy</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">total_energy(grids, lat, model) -&gt; Float64</code></pre><p>Calculates the total energy of the system. The default implementation sums up <a href="#Lattice2DMonteCarlo.local_hamiltonian-Union{Tuple{T}, Tuple{AbstractVector{T}, Lattice2D.Lattice, AbstractModel{T}, Int64}} where T"><code>local_hamiltonian</code></a> for all sites and divides by <code>2.0</code> to correct for double counting of interactions.</p><div class="admonition is-warning" id="Warning-ecf9bf144d2fc402"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-ecf9bf144d2fc402" title="Permalink"></a></header><div class="admonition-body"><p>For models containing terms that do not result in double counting (e.g., external field terms), this default implementation may be inaccurate. In such cases, please override this function for the specific model.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sotashimozono/Lattice2DMonteCarlo.jl/blob/42bb75a32aaf160dda86552f7be10326b3d87e04/src/core/interfaces.jl#L122-L131">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Lattice2DMonteCarlo.update_step!-Union{Tuple{T}, Tuple{Random.AbstractRNG, AbstractVector{T}, Lattice2D.Lattice, AbstractModel{T}, UpdateAlgorithm}} where T"><a class="docstring-binding" href="#Lattice2DMonteCarlo.update_step!-Union{Tuple{T}, Tuple{Random.AbstractRNG, AbstractVector{T}, Lattice2D.Lattice, AbstractModel{T}, UpdateAlgorithm}} where T"><code>Lattice2DMonteCarlo.update_step!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">update_step!(rng, grids, lat, model, alg; kbT=1.0)</code></pre><p>Performs updates for one Monte Carlo step (1 MCS). The specific process is dispatched to the type of <code>alg</code> (e.g., <a href="#Lattice2DMonteCarlo.LocalUpdateAlgorithm"><code>LocalUpdateAlgorithm</code></a> or <a href="#Lattice2DMonteCarlo.ClusterUpdateAlgorithm"><code>ClusterUpdateAlgorithm</code></a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sotashimozono/Lattice2DMonteCarlo.jl/blob/42bb75a32aaf160dda86552f7be10326b3d87e04/src/core/interfaces.jl#L162-L167">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Lattice2DMonteCarlo.FunctionObserver"><a class="docstring-binding" href="#Lattice2DMonteCarlo.FunctionObserver"><code>Lattice2DMonteCarlo.FunctionObserver</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">FunctionObserver(name::String, func::Function; interval::Int=100)</code></pre><p>A generic observer that tracks a scalar value returned by a custom function <code>func</code>.</p><p><strong>Fields</strong></p><ul><li><code>name::String</code>: The name of the observable (used as a column name in DataFrames).</li><li><code>measure_func::Function</code>: A function with signature <code>f(grids, lat, model)</code> returning a <code>Float64</code>.</li><li><code>interval::Int</code>: The frequency of observation (in Monte Carlo steps).</li><li><code>steps::Vector{Int}</code>: History of time steps where measurements were taken.</li><li><code>history::Vector{Float64}</code>: History of measured values.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sotashimozono/Lattice2DMonteCarlo.jl/blob/42bb75a32aaf160dda86552f7be10326b3d87e04/src/core/observers.jl#L21-L32">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Lattice2DMonteCarlo.ThermodynamicObserver"><a class="docstring-binding" href="#Lattice2DMonteCarlo.ThermodynamicObserver"><code>Lattice2DMonteCarlo.ThermodynamicObserver</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ThermodynamicObserver(; interval::Int=10)</code></pre><p>An observer designed to accumulate statistics required to calculate thermodynamic quantities such as Specific Heat and Susceptibility.</p><p><strong>accumulated Statistics</strong></p><ul><li><code>sum_E</code>, <code>sum_E2</code>: Sum of Energy and Energy squared.</li><li><code>sum_M</code>, <code>sum_M2</code>, <code>sum_M4</code>: Sum of Magnetization moments.</li><li><code>n_samples</code>: Total number of samples taken.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sotashimozono/Lattice2DMonteCarlo.jl/blob/42bb75a32aaf160dda86552f7be10326b3d87e04/src/core/observers.jl#L75-L85">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Lattice2DMonteCarlo.get_thermodynamics-Tuple{ThermodynamicObserver, Float64, Int64, AbstractModel}"><a class="docstring-binding" href="#Lattice2DMonteCarlo.get_thermodynamics-Tuple{ThermodynamicObserver, Float64, Int64, AbstractModel}"><code>Lattice2DMonteCarlo.get_thermodynamics</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_thermodynamics(obs::ThermodynamicObserver, kbT::Float64, N::Int, model::AbstractModel) -&gt; Dict</code></pre><p>Computes physical quantities using the accumulated statistics in the observer.</p><p><strong>Returns</strong></p><p>A Dictionary containing:</p><ul><li><code>&quot;Energy&quot;</code>: Internal energy density (E/N).</li><li><code>&quot;Magnetization&quot;</code>: Magnetization density (M).</li><li><code>&quot;SpecificHeat&quot;</code>: Heat capacity per site C<em>v = \frac{\text{var}(E)}{k</em>B T^2 N}.</li><li><code>&quot;Susceptibility&quot;</code>: Magnetic susceptibility \chi = \frac{\text{var}(M)}{k_B T} N.</li><li><code>&quot;BinderParam&quot;</code>: Binder cumulant U_4 = 1 - \frac{\langle M^4 \rangle}{3 \langle M^2 \rangle^2}.</li><li><code>&quot;Samples&quot;</code>: Number of samples used for the calculation.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sotashimozono/Lattice2DMonteCarlo.jl/blob/42bb75a32aaf160dda86552f7be10326b3d87e04/src/core/observers.jl#L119-L132">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Lattice2DMonteCarlo.measure_energy-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#Lattice2DMonteCarlo.measure_energy-Tuple{Any, Any, Any}"><code>Lattice2DMonteCarlo.measure_energy</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">measure_energy(grids, lat, model) -&gt; Float64</code></pre><p>Calculates the total energy of the system. This is a wrapper around <a href="#Lattice2DMonteCarlo.total_energy-Union{Tuple{T}, Tuple{AbstractVector{T}, Lattice2D.Lattice, AbstractModel{T}}} where T"><code>total_energy</code></a> to provide a consistent interface for observers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sotashimozono/Lattice2DMonteCarlo.jl/blob/42bb75a32aaf160dda86552f7be10326b3d87e04/src/core/observers.jl#L1-L6">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Lattice2DMonteCarlo.measure_magnetization-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#Lattice2DMonteCarlo.measure_magnetization-Tuple{Any, Any, Any}"><code>Lattice2DMonteCarlo.measure_magnetization</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">measure_magnetization(grids, lat, model) -&gt; Float64</code></pre><p>Calculates the magnetization (order parameter) of the system. This function must be implemented for each specific <code>model</code> type.</p><p><strong>Returns</strong></p><ul><li>The magnetization per site (usually normalized between 0 and 1).</li></ul><p><strong>Throws</strong></p><ul><li><code>ErrorException</code>: If not implemented for the specific model type.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sotashimozono/Lattice2DMonteCarlo.jl/blob/42bb75a32aaf160dda86552f7be10326b3d87e04/src/core/observers.jl#L8-L19">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Lattice2DMonteCarlo.observe!-Union{Tuple{T}, Tuple{FunctionObserver, AbstractVector{T}, Lattice2D.Lattice, Float64, AbstractModel{T}, Int64}} where T"><a class="docstring-binding" href="#Lattice2DMonteCarlo.observe!-Union{Tuple{T}, Tuple{FunctionObserver, AbstractVector{T}, Lattice2D.Lattice, Float64, AbstractModel{T}, Int64}} where T"><code>Lattice2DMonteCarlo.observe!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">observe!(obs, grids, lat, kbT, model, step)</code></pre><p>Records the state of the system into the observer.</p><ul><li>For <code>FunctionObserver</code>: Executes the user-defined measurement function.</li><li>For <code>ThermodynamicObserver</code>: Accumulates Energy (E, E^2) and Magnetization (M, M^2, M^4) statistics for post-processing.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sotashimozono/Lattice2DMonteCarlo.jl/blob/42bb75a32aaf160dda86552f7be10326b3d87e04/src/core/observers.jl#L45-L52">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Lattice2DMonteCarlo.to_dataframe-Tuple{FunctionObserver}"><a class="docstring-binding" href="#Lattice2DMonteCarlo.to_dataframe-Tuple{FunctionObserver}"><code>Lattice2DMonteCarlo.to_dataframe</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">to_dataframe(obs::FunctionObserver) -&gt; DataFrame</code></pre><p>Converts the recorded history of a <code>FunctionObserver</code> into a DataFrame. Returns columns <code>:Step</code> and <code>Symbol(obs.name)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sotashimozono/Lattice2DMonteCarlo.jl/blob/42bb75a32aaf160dda86552f7be10326b3d87e04/src/core/observers.jl#L66-L71">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../models/">Models »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Monday 15 December 2025 16:25">Monday 15 December 2025</span>. Using Julia version 1.12.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
