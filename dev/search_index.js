var documenterSearchIndex = {"docs":
[{"location":"core/#Core-and-Interfaces","page":"Core & Interfaces","title":"Core & Interfaces","text":"Base structures and abstract types for the simulation.","category":"section"},{"location":"core/#Lattice2DMonteCarlo.AbstractModel","page":"Core & Interfaces","title":"Lattice2DMonteCarlo.AbstractModel","text":"AbstractModel{T}: Abstract type for lattice models in Monte Carlo simulations. T: The state type of the model (e.g., Int, Float64, Vector, etc.). if you want to define a new model, subtype this abstract type.\n\n\n\n\n\n","category":"type"},{"location":"core/#Lattice2DMonteCarlo.AbstractMonteCarlo","page":"Core & Interfaces","title":"Lattice2DMonteCarlo.AbstractMonteCarlo","text":"AbstractMonteCarlo: Abstract type for Monte Carlo simulation components.\n\n\n\n\n\n","category":"type"},{"location":"core/#Lattice2DMonteCarlo.AbstractObserver","page":"Core & Interfaces","title":"Lattice2DMonteCarlo.AbstractObserver","text":"AbstractObserver: Abstract type for observers in Monte Carlo simulations. it is used to monitor physical quantities during the simulation.\n\n\n\n\n\n","category":"type"},{"location":"core/#Lattice2DMonteCarlo.AcceptanceRule","page":"Core & Interfaces","title":"Lattice2DMonteCarlo.AcceptanceRule","text":"AcceptanceRule: Abstract type for acceptance rules in Monte Carlo simulations. SiteSelectionMethod: Abstract type for site selection methods in Monte Carlo simulations.\n\n\n\n\n\n","category":"type"},{"location":"core/#Lattice2DMonteCarlo.ClusterUpdateAlgorithm","page":"Core & Interfaces","title":"Lattice2DMonteCarlo.ClusterUpdateAlgorithm","text":"ClusterUpdateAlgorithm: Abstract type for cluster update algorithms. it is used for wolff algorithm, swendsen-wang algorithm, etc.\n\n\n\n\n\n","category":"type"},{"location":"core/#Lattice2DMonteCarlo.Glauber","page":"Core & Interfaces","title":"Lattice2DMonteCarlo.Glauber","text":"Glauber: Acceptance rule based on the Glauber dynamics. 1 / (1 + e^(dE/kbT))\n\n\n\n\n\n","category":"type"},{"location":"core/#Lattice2DMonteCarlo.LocalChange","page":"Core & Interfaces","title":"Lattice2DMonteCarlo.LocalChange","text":"LocalChange{T}: Represents a local change at a single site. T: The state type of the model (e.g., Int, Float64, Vector, etc.).\n\n\n\n\n\n","category":"type"},{"location":"core/#Lattice2DMonteCarlo.LocalUpdate","page":"Core & Interfaces","title":"Lattice2DMonteCarlo.LocalUpdate","text":"LocalUpdate{R<:AcceptanceRule,S<:SiteSelectionMethod,P<:ProposalMethod}: Local update algorithm combining acceptance rule R, site selection method S, and proposal method P. this is a general structure for local update algorithms in Monte Carlo simulations.\n\n\n\n\n\n","category":"type"},{"location":"core/#Lattice2DMonteCarlo.LocalUpdateAlgorithm","page":"Core & Interfaces","title":"Lattice2DMonteCarlo.LocalUpdateAlgorithm","text":"LocalUpdateAlgorithm: Abstract type for local update algorithms. it is used for kawaski dynamics, metropolis updates, etc.\n\n\n\n\n\n","category":"type"},{"location":"core/#Lattice2DMonteCarlo.Metropolis","page":"Core & Interfaces","title":"Lattice2DMonteCarlo.Metropolis","text":"Metropolis: Acceptance rule based on the Metropolis criterion. e^(-dE/kbT)\n\n\n\n\n\n","category":"type"},{"location":"core/#Lattice2DMonteCarlo.ProposalMethod","page":"Core & Interfaces","title":"Lattice2DMonteCarlo.ProposalMethod","text":"ProposalMethod: Abstract type for proposal methods in Monte Carlo simulations.\n\n\n\n\n\n","category":"type"},{"location":"core/#Lattice2DMonteCarlo.RandomSiteSelection","page":"Core & Interfaces","title":"Lattice2DMonteCarlo.RandomSiteSelection","text":"RandomSiteSelection: Site selection method that selects sites randomly. when you consider non equilibrium dynamics, this method is recommended.\n\n\n\n\n\n","category":"type"},{"location":"core/#Lattice2DMonteCarlo.SequentialSweep","page":"Core & Interfaces","title":"Lattice2DMonteCarlo.SequentialSweep","text":"SequentialSweep: Site selection method that sweeps through sites sequentially.\n\n\n\n\n\n","category":"type"},{"location":"core/#Lattice2DMonteCarlo.SiteSelectionMethod","page":"Core & Interfaces","title":"Lattice2DMonteCarlo.SiteSelectionMethod","text":"SiteSelectionMethod: Abstract type for site selection methods in Monte Carlo simulations.\n\n\n\n\n\n","category":"type"},{"location":"core/#Lattice2DMonteCarlo.SpinExchange","page":"Core & Interfaces","title":"Lattice2DMonteCarlo.SpinExchange","text":"SpinExchange: Proposal method for exchanging spins between two sites (e.g., in Kawasaki dynamics). conserved dynamics.\n\n\n\n\n\n","category":"type"},{"location":"core/#Lattice2DMonteCarlo.SpinFlip","page":"Core & Interfaces","title":"Lattice2DMonteCarlo.SpinFlip","text":"Spinfilp: Proposal method for flipping spins (e.g., in Ising model). non conserved dynamics.\n\n\n\n\n\n","category":"type"},{"location":"core/#Lattice2DMonteCarlo.UniformShift","page":"Core & Interfaces","title":"Lattice2DMonteCarlo.UniformShift","text":"UniformShift(width::Float64 = 0.1) A proposal method for continuous spin models (e.g., XY, Heisenberg). Shifts the current value by a random amount drawn uniformly from [-width/2, width/2].\n\n\n\n\n\n","category":"type"},{"location":"core/#Lattice2DMonteCarlo.UpdateAlgorithm","page":"Core & Interfaces","title":"Lattice2DMonteCarlo.UpdateAlgorithm","text":"UpdateAlgorithm: Abstract type for update algorithms in Monte Carlo simulations.\n\n\n\n\n\n","category":"type"},{"location":"core/#Lattice2DMonteCarlo.calculate_diff_energy-Union{Tuple{T}, Tuple{AbstractVector{T}, Lattice2D.Lattice, AbstractModel{T}, Tuple{LocalChange{T}, LocalChange{T}, Vararg{LocalChange{T}}}}} where T","page":"Core & Interfaces","title":"Lattice2DMonteCarlo.calculate_diff_energy","text":"calculate_diff_energy(grids, lat, model, changes) -> Float64\n\nEfficiently calculates the energy difference \\Delta E associated with the proposed changes. Instead of recalculating the total energy, it considers only the changed sites and their neighbors.\n\nArguments\n\nchanges: A tuple of LocalChange.\n\n\n\n\n\n","category":"method"},{"location":"core/#Lattice2DMonteCarlo.check_acceptance-Tuple{Random.AbstractRNG, AcceptanceRule, Float64}","page":"Core & Interfaces","title":"Lattice2DMonteCarlo.check_acceptance","text":"check_acceptance(rng, rule, dE; kbT) -> Bool\n\nDetermines whether to accept the state transition based on the energy difference dE and temperature kbT.\n\nArguments\n\nrule::AcceptanceRule: The acceptance rule (e.g., Metropolis, Glauber).\ndE::Float64: The energy difference (E{new} - E{old}).\n\nReturns\n\nBool: true if the transition is accepted.\n\n\n\n\n\n","category":"method"},{"location":"core/#Lattice2DMonteCarlo.local_hamiltonian-Union{Tuple{T}, Tuple{AbstractVector{T}, Lattice2D.Lattice, AbstractModel{T}, Int64}} where T","page":"Core & Interfaces","title":"Lattice2DMonteCarlo.local_hamiltonian","text":"local_hamiltonian(grids, lat, model, site; val=grids[site]) -> Float64\n\nCalculates the local interaction energy around the specified site. A virtual value val can be specified instead of the current state grids[site] for calculating energy differences.\n\nArguments\n\nsite::Int: The site index for calculation.\nval::T: The state value of the site. Defaults to the current grids[site].\n\nReturns\n\nFloat64: The local energy value.\n\n\n\n\n\n","category":"method"},{"location":"core/#Lattice2DMonteCarlo.observe!-Union{Tuple{T}, Tuple{AbstractObserver, AbstractVector{T}, Lattice2D.Lattice, AbstractModel{T}, Int64}} where T","page":"Core & Interfaces","title":"Lattice2DMonteCarlo.observe!","text":"observe!(obs, grids, lat, kbT, model, step)\n\nMeasures and records physical quantities from the current state. This function is called periodically within the run! loop.\n\nArguments\n\nobs::AbstractObserver: The specific observer instance (e.g., FunctionObserver).\nstep::Int: The current Monte Carlo step number.\n\n\n\n\n\n","category":"method"},{"location":"core/#Lattice2DMonteCarlo.process_site_selection!-Union{Tuple{T}, Tuple{Random.AbstractRNG, SiteSelectionMethod, AbstractVector{T}, Lattice2D.Lattice, AbstractModel{T}, UpdateAlgorithm}} where T","page":"Core & Interfaces","title":"Lattice2DMonteCarlo.process_site_selection!","text":"process_site_selection!(rng, S, grids, lat, model, alg; kbT=1.0)\n\nCalled as part of the LocalUpdate algorithm. Selects a site based on the SiteSelectionMethod S, then executes propose and check_acceptance.\n\nArguments\n\nS::SiteSelectionMethod: The site selection strategy (e.g., RandomSiteSelection).\n\n\n\n\n\n","category":"method"},{"location":"core/#Lattice2DMonteCarlo.propose-Union{Tuple{T}, Tuple{Random.AbstractRNG, ProposalMethod, AbstractVector{T}, Lattice2D.Lattice, AbstractModel{T}, Int64}} where T","page":"Core & Interfaces","title":"Lattice2DMonteCarlo.propose","text":"propose(rng, alg, grids, lat, model, site) -> Tuple{LocalChange, ...}\n\nProposes a new candidate state for a local update algorithm. This function does not actually modify grids, but returns a tuple of LocalChange representing the proposed modifications.\n\nArguments\n\nalg::ProposalMethod: The proposal method (e.g., SpinFlip, SpinExchange).\nsite::Int: The index of the site to be updated.\n\nReturns\n\nTuple{Vararg{LocalChange{T}}}: A tuple containing change information for one or more sites.\n\n\n\n\n\n","category":"method"},{"location":"core/#Lattice2DMonteCarlo.run!-Union{Tuple{T}, Tuple{Random.AbstractRNG, AbstractVector{T}, Lattice2D.Lattice, AbstractModel{T}, UpdateAlgorithm, AbstractVector{<:AbstractObserver}}} where T","page":"Core & Interfaces","title":"Lattice2DMonteCarlo.run!","text":"run!(rng, grids, lat, model, alg, observers; kbT=1.0, nsteps=1000, kwargs...)\n\nRun a Monte Carlo simulation with the specified parameters, updating the spin configuration grids in place.\n\nArguments\n\nrng::AbstractRNG: random number generator for stochastic processes.\ngrids::AbstractVector{T}: it represents the spin configuration of the lattice, where T is the type of spin (e.g., Int for Ising spins).\nlat::Lattice: lattice structure (topology, size, adjacency information).\nmodel::AbstractModel{T}: definition of the physical model (Ising, Potts, XY, etc.).\nalg::UpdateAlgorithm: update algorithm (e.g., LocalUpdate).\nobservers::AbstractVector: list of AbstractObservers for measurements.\n\nKeyword Arguments\n\nkbT::Float64:  k_BT value for the simulation. Default is 1.0.\nnsteps::Int: total number of simulation steps (MCS). Default is 1000.\nkwargs...: other algorithm-specific parameters.\n\nExecution Flow\n\nInitial Observation: Record the state at step 0 using observe!.\nSimulation Loop: Loop for nsteps iterations.\nupdate_step!: Perform one Monte Carlo step update.\nInterval Observation: Call observe! when step % obs.interval == 0.\n\n\n\n\n\n","category":"method"},{"location":"core/#Lattice2DMonteCarlo.run-Union{Tuple{T}, Tuple{Random.AbstractRNG, AbstractVector{T}, Lattice2D.Lattice, AbstractModel{T}, UpdateAlgorithm, AbstractVector{<:AbstractObserver}}} where T","page":"Core & Interfaces","title":"Lattice2DMonteCarlo.run","text":"run(rng, grids, lat, model, alg, observers; kwargs...) -> Vector{T}\n\nrun! that returns a new spin configuration without modifying the original grids.\n\n\n\n\n\n","category":"method"},{"location":"core/#Lattice2DMonteCarlo.total_energy-Union{Tuple{T}, Tuple{AbstractVector{T}, Lattice2D.Lattice, AbstractModel{T}}} where T","page":"Core & Interfaces","title":"Lattice2DMonteCarlo.total_energy","text":"total_energy(grids, lat, model) -> Float64\n\nCalculates the total energy of the system. The default implementation sums up local_hamiltonian for all sites and divides by 2.0 to correct for double counting of interactions.\n\nwarning: Warning\nFor models containing terms that do not result in double counting (e.g., external field terms), this default implementation may be inaccurate. In such cases, please override this function for the specific model.\n\n\n\n\n\n","category":"method"},{"location":"core/#Lattice2DMonteCarlo.update_step!-Union{Tuple{T}, Tuple{Random.AbstractRNG, AbstractVector{T}, Lattice2D.Lattice, AbstractModel{T}, UpdateAlgorithm}} where T","page":"Core & Interfaces","title":"Lattice2DMonteCarlo.update_step!","text":"update_step!(rng, grids, lat, model, alg; kbT=1.0)\n\nPerforms updates for one Monte Carlo step (1 MCS). The specific process is dispatched to the type of alg (e.g., LocalUpdateAlgorithm or ClusterUpdateAlgorithm).\n\n\n\n\n\n","category":"method"},{"location":"core/#Lattice2DMonteCarlo.FunctionObserver","page":"Core & Interfaces","title":"Lattice2DMonteCarlo.FunctionObserver","text":"FunctionObserver(name::String, func::Function; interval::Int=100)\n\nA generic observer that tracks a scalar value returned by a custom function func.\n\nFields\n\nname::String: The name of the observable (used as a column name in DataFrames).\nmeasure_func::Function: A function with signature f(grids, lat, model) returning a Float64.\ninterval::Int: The frequency of observation (in Monte Carlo steps).\nsteps::Vector{Int}: History of time steps where measurements were taken.\nhistory::Vector{Float64}: History of measured values.\n\n\n\n\n\n","category":"type"},{"location":"core/#Lattice2DMonteCarlo.ThermodynamicObserver","page":"Core & Interfaces","title":"Lattice2DMonteCarlo.ThermodynamicObserver","text":"ThermodynamicObserver(; interval::Int=10)\n\nAn observer designed to accumulate statistics required to calculate thermodynamic quantities such as Specific Heat and Susceptibility.\n\naccumulated Statistics\n\nsum_E, sum_E2: Sum of Energy and Energy squared.\nsum_M, sum_M2, sum_M4: Sum of Magnetization moments.\nn_samples: Total number of samples taken.\n\n\n\n\n\n","category":"type"},{"location":"core/#Lattice2DMonteCarlo.get_thermodynamics-Tuple{ThermodynamicObserver, Float64, Int64, AbstractModel}","page":"Core & Interfaces","title":"Lattice2DMonteCarlo.get_thermodynamics","text":"get_thermodynamics(obs::ThermodynamicObserver, kbT::Float64, N::Int, model::AbstractModel) -> Dict\n\nComputes physical quantities using the accumulated statistics in the observer.\n\nReturns\n\nA Dictionary containing:\n\n\"Energy\": Internal energy density (E/N).\n\"Magnetization\": Magnetization density (M).\n\"SpecificHeat\": Heat capacity per site Cv = \\frac{\\text{var}(E)}{kB T^2 N}.\n\"Susceptibility\": Magnetic susceptibility \\chi = \\frac{\\text{var}(M)}{k_B T} N.\n\"BinderParam\": Binder cumulant U_4 = 1 - \\frac{\\langle M^4 \\rangle}{3 \\langle M^2 \\rangle^2}.\n\"Samples\": Number of samples used for the calculation.\n\n\n\n\n\n","category":"method"},{"location":"core/#Lattice2DMonteCarlo.measure_energy-Tuple{Any, Any, Any}","page":"Core & Interfaces","title":"Lattice2DMonteCarlo.measure_energy","text":"measure_energy(grids, lat, model) -> Float64\n\nCalculates the total energy of the system. This is a wrapper around total_energy to provide a consistent interface for observers.\n\n\n\n\n\n","category":"method"},{"location":"core/#Lattice2DMonteCarlo.measure_magnetization-Tuple{Any, Any, Any}","page":"Core & Interfaces","title":"Lattice2DMonteCarlo.measure_magnetization","text":"measure_magnetization(grids, lat, model) -> Float64\n\nCalculates the magnetization (order parameter) of the system. This function must be implemented for each specific model type.\n\nReturns\n\nThe magnetization per site (usually normalized between 0 and 1).\n\nThrows\n\nErrorException: If not implemented for the specific model type.\n\n\n\n\n\n","category":"method"},{"location":"core/#Lattice2DMonteCarlo.observe!-Union{Tuple{T}, Tuple{FunctionObserver, AbstractVector{T}, Lattice2D.Lattice, Float64, AbstractModel{T}, Int64}} where T","page":"Core & Interfaces","title":"Lattice2DMonteCarlo.observe!","text":"observe!(obs, grids, lat, kbT, model, step)\n\nRecords the state of the system into the observer.\n\nFor FunctionObserver: Executes the user-defined measurement function.\nFor ThermodynamicObserver: Accumulates Energy (E, E^2) and Magnetization (M, M^2, M^4) statistics for post-processing.\n\n\n\n\n\n","category":"method"},{"location":"core/#Lattice2DMonteCarlo.to_dataframe-Tuple{FunctionObserver}","page":"Core & Interfaces","title":"Lattice2DMonteCarlo.to_dataframe","text":"to_dataframe(obs::FunctionObserver) -> DataFrame\n\nConverts the recorded history of a FunctionObserver into a DataFrame. Returns columns :Step and Symbol(obs.name).\n\n\n\n\n\n","category":"method"},{"location":"models/#Physical-Models","page":"Models","title":"Physical Models","text":"Implementations of various statistical mechanics models.","category":"section"},{"location":"models/#Lattice2DMonteCarlo.IsingModel","page":"Models","title":"Lattice2DMonteCarlo.IsingModel","text":"IsingModel(J::Float64=1.0, h::Float64=0.0)\n\nRepresents the classical Ising model with spins s_i \\in {-1, 1}.\n\nHamiltonian\n\nH = -J \\sum{\\langle i, j \\rangle} si sj - h \\sumi s_i\n\nJ: Interaction constant (ferromagnetic if J>0).\nh: External magnetic field.\n\n\n\n\n\n","category":"type"},{"location":"models/#Lattice2DMonteCarlo.calculate_diff_energy-Tuple{AbstractVector{Int64}, Lattice2D.Lattice, IsingModel, Tuple{LocalChange{Int64}, LocalChange{Int64}}}","page":"Models","title":"Lattice2DMonteCarlo.calculate_diff_energy","text":"calculate_diff_energy(grids, lat, model::IsingModel, changes::Tuple{LocalChange, LocalChange})\n\nCalculates the energy difference for a two-site update (Spin Exchange).\n\nLogic\n\nIt sums the local energy differences of both sites. Crucially, if the swapped sites are nearest neighbors, it subtracts the bond energy correction to prevent double-counting the interaction between site1 and site2.\n\n\n\n\n\n","category":"method"},{"location":"models/#Lattice2DMonteCarlo.local_hamiltonian-Tuple{AbstractVector{Int64}, Lattice2D.Lattice, IsingModel, Int64}","page":"Models","title":"Lattice2DMonteCarlo.local_hamiltonian","text":"local_hamiltonian(grids, lat, model::IsingModel, site; val)\n\nCalculates the local energy contribution of a single site. E{local} = -J \\sum{k \\in \\text{neighbors}} s{\\text{site}} sk - h s_{\\text{site}}\n\n\n\n\n\n","category":"method"},{"location":"models/#Lattice2DMonteCarlo.measure_magnetization-Tuple{Any, Any, IsingModel}","page":"Models","title":"Lattice2DMonteCarlo.measure_magnetization","text":"measure_magnetization(grids, lat, ::IsingModel)\n\nCalculates the magnetization per site: M = \\frac{1}{N} |\\sum s_i|.\n\n\n\n\n\n","category":"method"},{"location":"models/#Lattice2DMonteCarlo.propose-Tuple{Random.AbstractRNG, SpinFlip, AbstractVector{Int64}, Lattice2D.Lattice, IsingModel, Int64}","page":"Models","title":"Lattice2DMonteCarlo.propose","text":"propose(rng, ::SpinFlip, ..., model::IsingModel, site)\n\nProposes a standard Glauber/Metropolis flip: s{new} = -s{old}.\n\n\n\n\n\n","category":"method"},{"location":"models/#Lattice2DMonteCarlo.total_energy-Tuple{AbstractVector{Int64}, Lattice2D.Lattice, IsingModel}","page":"Models","title":"Lattice2DMonteCarlo.total_energy","text":"total_energy(grids, lat, model::IsingModel)\n\nCalculates the total energy of the Ising system. Includes a factor of 1/2 for the bond sum to avoid double counting edges.\n\n\n\n\n\n","category":"method"},{"location":"models/#Lattice2DMonteCarlo.PottsModel","page":"Models","title":"Lattice2DMonteCarlo.PottsModel","text":"PottsModel(q::Int=3, J::Float64=1.0)\n\nRepresents the q-state Potts model. Spins take values s_i \\in {1, 2, \\dots, q}.\n\nHamiltonian\n\nH = -J \\sum{\\langle i, j \\rangle} \\delta(si, s_j) where \\delta is the Kronecker delta (1 if equal, 0 otherwise).\n\n\n\n\n\n","category":"type"},{"location":"models/#Lattice2DMonteCarlo.measure_magnetization-Tuple{Any, Any, PottsModel}","page":"Models","title":"Lattice2DMonteCarlo.measure_magnetization","text":"measure_magnetization(grids, lat, model::PottsModel)\n\nCalculates the order parameter for the Potts model based on the density of the majority spin.\n\nFormula\n\nM = \\frac{q \\rho{max} - 1}{q - 1} where \\rho{max} is the fraction of sites occupied by the most common spin state. This ensures M=1 for a fully ordered state and M=0 for a disordered state.\n\n\n\n\n\n","category":"method"},{"location":"models/#Lattice2DMonteCarlo.propose-Tuple{Random.AbstractRNG, SpinFlip, AbstractVector{Int64}, Lattice2D.Lattice, PottsModel, Int64}","page":"Models","title":"Lattice2DMonteCarlo.propose","text":"propose(rng, ::SpinFlip, ..., model::PottsModel, site)\n\nProposes a new state for the Potts model. The new state is chosen uniformly at random from the q-1 states that are not the current state.\n\n\n\n\n\n","category":"method"},{"location":"models/#Lattice2DMonteCarlo.XYModel","page":"Models","title":"Lattice2DMonteCarlo.XYModel","text":"XYModel(J::Float64=1.0)\n\nRepresents the classical XY model with continuous planar spins \\theta_i \\in [0, 2\\pi).\n\nHamiltonian\n\nH = -J \\sum{\\langle i, j \\rangle} \\cos(\\thetai - \theta_j)\n\n\n\n\n\n","category":"type"},{"location":"models/#Lattice2DMonteCarlo.get_binder_coeff-Tuple{XYModel}","page":"Models","title":"Lattice2DMonteCarlo.get_binder_coeff","text":"get_binder_coeff(model) -> Float64\n\nReturns the coefficient used in the denominator of the Binder Cumulant calculation (3 \\langle M^2 \\rangle^2).\n\nIsingModel: 3.0 (Scalar order parameter, Gaussian universality).\nPottsModel: 3.0.\nXYModel: 2.0 (Vector order parameter with 2 components).\n\n\n\n\n\n","category":"method"},{"location":"models/#Lattice2DMonteCarlo.measure_magnetization-Tuple{Any, Any, XYModel}","page":"Models","title":"Lattice2DMonteCarlo.measure_magnetization","text":"measure_magnetization(grids, lat, ::XYModel)\n\nCalculates the magnetization magnitude for the XY model. It treats the spins as unit vectors \\vec{S}i = (\\cos \\thetai, \\sin \\theta_i).\n\nFormula\n\nM = \\frac{1}{N} \\left| \\sumi \\vec{S}i \\right|\n\n\n\n\n\n","category":"method"},{"location":"models/#Lattice2DMonteCarlo.propose-Tuple{Random.AbstractRNG, UniformShift, AbstractVector{Float64}, Lattice2D.Lattice, XYModel, Int64}","page":"Models","title":"Lattice2DMonteCarlo.propose","text":"propose(rng, alg::UniformShift, ..., model::XYModel, site)\n\nProposes a change to the angle \\theta by shifting it by a random amount \\delta. \\theta{new} = \\theta{old} + \\delta, where \\delta \\in [-\\text{width}/2, \\text{width}/2].\n\n\n\n\n\n","category":"method"},{"location":"visualization/#Visualization","page":"Visualization","title":"Visualization","text":"Tools for visualizing lattice states and simulation snapshots.\n\n```@autodocs Modules = [Lattice2DMonteCarlo] Pages = [     \"utils/visualize.jl\" ] â€“-","category":"section"},{"location":"#Lattice2DMonteCarlo.jl","page":"Home","title":"Lattice2DMonteCarlo.jl","text":"Overview of the 2D Lattice Monte Carlo simulation package.\n\nLattice2DMonteCarlo.jl is an example application of the Lattice2D package. It provides implementations of various classical lattice systems. By adhering to specific interfaces, you can easily implement custom models or update algorithms.","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"using Pkg\nPkg.add(url=\"https://github.com/sotashimozono/Lattice2DMonteCarlo.jl\")","category":"section"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"using Lattice2D\nusing Lattice2DMonteCarlo\nusing Random\n\n# 1. Setup Lattice and Model\nlat = build_lattice(Honeycomb, 10, 10)\nmodel = IsingModel(J=1.0, h=0.0)\n\n# 2. Initialize State\nrng = Random.default_rng()\n# Random initial configuration (+1 or -1)\ngrids = rand(rng, [-1, 1], lat.N)\n\n# 3. Define Algorithm and Observer\nalg = LocalUpdate(rule=Metropolis(), proposal=SpinFlip())\nobs = FunctionObserver(\"Magnetization\", measure_magnetization)\n\n# 4. Simulation Loop\nkbT = 2.269 # Critical temperature\nn_steps = 1000\n\nfor step in 1:n_steps\n    update_step!(rng, grids, lat, model, alg; kbT=kbT)\n    observe!(obs, grids, lat, kbT, model, step)\nend\n\ndf = to_dataframe(obs)\ndisplay(first(df, 5))","category":"section"},{"location":"algorithms/#Update-Algorithms","page":"Algorithms","title":"Update Algorithms","text":"Monte Carlo update algorithms and acceptance rules.","category":"section"},{"location":"algorithms/#Lattice2DMonteCarlo.calculate_diff_energy-Union{Tuple{T}, Tuple{AbstractVector{T}, Lattice2D.Lattice, AbstractModel{T}, Tuple{LocalChange{T}}}} where T","page":"Algorithms","title":"Lattice2DMonteCarlo.calculate_diff_energy","text":"calculate_diff_energy(grids, lat, model, changes; kwargs...) -> Float64\n\nCalculates the energy difference \\Delta E = E{new} - E{old} caused by the proposed changes.\n\nArguments\n\nchanges: A tuple of LocalChange structs.\nIf a single change is passed, it uses local_hamiltonian difference.\nIf multiple changes are passed, a specialized method must be implemented for the model.\n\n\n\n\n\n","category":"method"},{"location":"algorithms/#Lattice2DMonteCarlo.check_acceptance-Tuple{Random.AbstractRNG, Metropolis, Float64, Float64}","page":"Algorithms","title":"Lattice2DMonteCarlo.check_acceptance","text":"check_acceptance(rng, rule, dE, kbT) -> Bool\n\nDetermines if a proposed move with energy difference dE should be accepted at temperature kbT.\n\nStrategies\n\n::Metropolis: Accepts if r < e^{-\\Delta E / k_B T}. Always accepts if \\Delta E \\leq 0.\n::Glauber: Accepts if r < \\frac{1}{1 + e^{\\Delta E / k_B T}}.\n\n\n\n\n\n","category":"method"},{"location":"algorithms/#Lattice2DMonteCarlo.process_site_selection!","page":"Algorithms","title":"Lattice2DMonteCarlo.process_site_selection!","text":"process_site_selection!(rng, selection_method, grids, lat, model, alg; kwargs...)\n\nIterates through lattice sites based on the specified selection_method (Sweep vs Random) and triggers single-site updates.\n\nMethods\n\n::SequentialSweep: Iterates from site 1 to lat.N in order.\n::RandomSiteSelection: Performs lat.N updates, choosing a random site index each time.\n\n\n\n\n\n","category":"function"},{"location":"algorithms/#Lattice2DMonteCarlo.update_single_site!-Union{Tuple{T}, Tuple{Random.AbstractRNG, Int64, AbstractVector{T}, Lattice2D.Lattice, AbstractModel{T}, LocalUpdate}} where T","page":"Algorithms","title":"Lattice2DMonteCarlo.update_single_site!","text":"update_single_site!(rng, site, grids, lat, model, alg; kbT, kwargs...)\n\nThe core logic for a local Monte Carlo update at a specific site.\n\nPropose: Generates a set of LocalChange candidates using alg.proposal.\nEnergy Diff: Calculates \\Delta E resulting from the proposed changes.\nAccept/Reject: Decides whether to accept the change based on alg.rule (e.g., Metropolis) and temperature kbT.\nUpdate: If accepted, applies the changes to grids.\n\n\n\n\n\n","category":"method"},{"location":"algorithms/#Lattice2DMonteCarlo.update_step!-Union{Tuple{T}, Tuple{Random.AbstractRNG, AbstractVector{T}, Lattice2D.Lattice, AbstractModel{T}, LocalUpdate}} where T","page":"Algorithms","title":"Lattice2DMonteCarlo.update_step!","text":"update_step!(rng, grids, lat, model, alg::LocalUpdate; kwargs...)\n\nPerforms one full Monte Carlo step (MCS). For a local update algorithm, this typically consists of N single-site update attempts, where N is the system size.\n\n\n\n\n\n","category":"method"}]
}
